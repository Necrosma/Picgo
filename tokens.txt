FN_KW: fn
IDENT: fib
L_PAREN: (
IDENT: n
COLON: :
IDENT: int
R_PAREN: )
ARROW: ->
IDENT: int
L_BRACE: {
IF_KW: if
IDENT: n
LT: <
UINT_LITERAL: 0
L_BRACE: {
RETURN_KW: return
MINUS: -
UINT_LITERAL: 1
SEMICOLON: ;
R_BRACE: }
ELSE_KW: else
IF_KW: if
IDENT: n
EQ: ==
UINT_LITERAL: 0
L_BRACE: {
RETURN_KW: return
UINT_LITERAL: 0
SEMICOLON: ;
R_BRACE: }
ELSE_KW: else
IF_KW: if
IDENT: n
EQ: ==
UINT_LITERAL: 1
L_BRACE: {
RETURN_KW: return
UINT_LITERAL: 1
SEMICOLON: ;
R_BRACE: }
ELSE_KW: else
L_BRACE: {
RETURN_KW: return
IDENT: fib
L_PAREN: (
IDENT: n
MINUS: -
UINT_LITERAL: 2
R_PAREN: )
PLUS: +
IDENT: fib
L_PAREN: (
IDENT: n
MINUS: -
UINT_LITERAL: 1
R_PAREN: )
SEMICOLON: ;
R_BRACE: }
R_BRACE: }
FN_KW: fn
IDENT: main
L_PAREN: (
R_PAREN: )
ARROW: ->
IDENT: int
L_BRACE: {
LET_KW: let
IDENT: i
COLON: :
IDENT: int
ASSIGN: =
UINT_LITERAL: 0
SEMICOLON: ;
LET_KW: let
IDENT: max
COLON: :
IDENT: int
ASSIGN: =
UINT_LITERAL: 0
SEMICOLON: ;
IDENT: max
ASSIGN: =
GETINT: getint
L_PAREN: (
R_PAREN: )
SEMICOLON: ;
IF_KW: if
IDENT: max
GT: >
UINT_LITERAL: 20
L_BRACE: {
IDENT: max
ASSIGN: =
UINT_LITERAL: 21
SEMICOLON: ;
R_BRACE: }
ELSE_KW: else
IF_KW: if
IDENT: max
LT: <
UINT_LITERAL: 0
L_BRACE: {
PUTINT: putint
L_PAREN: (
MINUS: -
UINT_LITERAL: 1
R_PAREN: )
SEMICOLON: ;
RETURN_KW: return
UINT_LITERAL: 0
SEMICOLON: ;
R_BRACE: }
ELSE_KW: else
L_BRACE: {
R_BRACE: }
WHILE_KW: while
IDENT: i
LE: <=
IDENT: max
L_BRACE: {
PUTINT: putint
L_PAREN: (
IDENT: fib
L_PAREN: (
IDENT: i
R_PAREN: )
R_PAREN: )
SEMICOLON: ;
PUTLN: putln
L_PAREN: (
R_PAREN: )
SEMICOLON: ;
IDENT: i
ASSIGN: =
IDENT: i
PLUS: +
UINT_LITERAL: 1
SEMICOLON: ;
R_BRACE: }
RETURN_KW: return
UINT_LITERAL: 0
SEMICOLON: ;
R_BRACE: }
