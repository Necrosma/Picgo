FN_KW: fn
IDENT: sqrt
L_PAREN: (
IDENT: n
COLON: :
IDENT: double
R_PAREN: )
ARROW: ->
IDENT: double
L_BRACE: {
LET_KW: let
IDENT: l
COLON: :
IDENT: double
ASSIGN: =
DOUBLE_LITERAL: 0
SEMICOLON: ;
LET_KW: let
IDENT: r
COLON: :
IDENT: double
ASSIGN: =
IDENT: n
SEMICOLON: ;
LET_KW: let
IDENT: mid
COLON: :
IDENT: double
SEMICOLON: ;
LET_KW: let
IDENT: mid2
COLON: :
IDENT: double
SEMICOLON: ;
WHILE_KW: while
IDENT: r
MINUS: -
IDENT: l
GT: >
DOUBLE_LITERAL: 1e-06
L_BRACE: {
IDENT: mid
ASSIGN: =
L_PAREN: (
IDENT: l
PLUS: +
IDENT: r
R_PAREN: )
DIV: /
DOUBLE_LITERAL: 2
SEMICOLON: ;
IDENT: mid2
ASSIGN: =
IDENT: mid
MUL: *
IDENT: mid
SEMICOLON: ;
IF_KW: if
L_PAREN: (
IDENT: mid2
EQ: ==
IDENT: n
R_PAREN: )
L_BRACE: {
RETURN_KW: return
IDENT: mid
SEMICOLON: ;
R_BRACE: }
IF_KW: if
L_PAREN: (
IDENT: mid2
LT: <
IDENT: n
R_PAREN: )
L_BRACE: {
IDENT: l
ASSIGN: =
IDENT: mid
SEMICOLON: ;
R_BRACE: }
ELSE_KW: else
L_BRACE: {
IDENT: r
ASSIGN: =
IDENT: mid
SEMICOLON: ;
R_BRACE: }
R_BRACE: }
RETURN_KW: return
IDENT: mid
SEMICOLON: ;
R_BRACE: }
FN_KW: fn
IDENT: mod
L_PAREN: (
IDENT: i
COLON: :
IDENT: int
COMMA: ,
IDENT: j
COLON: :
IDENT: int
R_PAREN: )
ARROW: ->
IDENT: int
L_BRACE: {
LET_KW: let
IDENT: k
COLON: :
IDENT: int
ASSIGN: =
L_PAREN: (
IDENT: i
DIV: /
IDENT: j
R_PAREN: )
AS_KW: as
IDENT: int
SEMICOLON: ;
RETURN_KW: return
L_PAREN: (
IDENT: i
MINUS: -
IDENT: j
MUL: *
IDENT: k
R_PAREN: )
AS_KW: as
IDENT: int
SEMICOLON: ;
R_BRACE: }
FN_KW: fn
IDENT: judge_mod
L_PAREN: (
IDENT: i
COLON: :
IDENT: int
COMMA: ,
IDENT: j
COLON: :
IDENT: int
COMMA: ,
IDENT: sq
COLON: :
IDENT: int
R_PAREN: )
ARROW: ->
IDENT: int
L_BRACE: {
IF_KW: if
IDENT: j
GT: >
IDENT: sq
L_BRACE: {
RETURN_KW: return
UINT_LITERAL: 0
SEMICOLON: ;
R_BRACE: }
ELSE_KW: else
IF_KW: if
IDENT: mod
L_PAREN: (
IDENT: i
COMMA: ,
IDENT: j
R_PAREN: )
EQ: ==
UINT_LITERAL: 0
L_BRACE: {
RETURN_KW: return
UINT_LITERAL: 0
SEMICOLON: ;
R_BRACE: }
ELSE_KW: else
L_BRACE: {
RETURN_KW: return
UINT_LITERAL: 1
SEMICOLON: ;
R_BRACE: }
R_BRACE: }
FN_KW: fn
IDENT: main
L_PAREN: (
R_PAREN: )
ARROW: ->
IDENT: void
L_BRACE: {
LET_KW: let
IDENT: N
COLON: :
IDENT: int
SEMICOLON: ;
LET_KW: let
IDENT: i
COLON: :
IDENT: int
SEMICOLON: ;
LET_KW: let
IDENT: j
COLON: :
IDENT: int
SEMICOLON: ;
LET_KW: let
IDENT: sq
COLON: :
IDENT: int
SEMICOLON: ;
LET_KW: let
IDENT: sqd
COLON: :
IDENT: double
SEMICOLON: ;
IDENT: N
ASSIGN: =
GETINT: getint
L_PAREN: (
R_PAREN: )
SEMICOLON: ;
IDENT: i
ASSIGN: =
UINT_LITERAL: 2
SEMICOLON: ;
WHILE_KW: while
IDENT: i
LE: <=
IDENT: N
L_BRACE: {
IF_KW: if
IDENT: mod
L_PAREN: (
IDENT: i
COMMA: ,
UINT_LITERAL: 2
R_PAREN: )
NEQ: !=
UINT_LITERAL: 0
L_BRACE: {
IDENT: sqd
ASSIGN: =
IDENT: sqrt
L_PAREN: (
IDENT: i
AS_KW: as
IDENT: double
R_PAREN: )
